# 数字底座接入文档

## 应用介绍
数字底座为不同渠道应用提供两种方式的数据接入，任意格式的文件和文本数据。可以是加工和未加工的数据形式。数字底座具备多路并发数据分发能力。

## 主要功能：

### 1.用户权限体系

### 2.数据接入
数字底座支持文件数据接入和文本数据接入两种方式。文件数据存储于MinIO，文本数据存储于elasticsearch。支持自定义MinIO bucket 和 Elasticsearch index。并将数据存储到指定的bucket 和index中。均可以在数字底座平台上完成相关操作。

**基础术语：**

bucket：文件数据隔离维度，即为MinIO 的桶概念。bucket 名称只支持英文小写，不符合规范无法成功创建bucket。同一个bucket 下的文件名必须唯一，否则后上传的会自动覆盖之前上传的文件。不同bucket 下的文件名可以重复。

index: 文本数据隔离维度，即为Elasticsearch 的index概念。index名称只支持英文小写和数字，不符合命名规范无法成功创建索引。

#### 2.1文件数据接入
文件接入支持自定义bucket，并将数据上传到指定的bucket中。

##### 2.1.1 文件存储设置
登录成功后即可在 数字底座 -> 文件 菜单下设置文件存储隔离并上传文件。点击 新建桶 按钮，在弹出的弹窗中输入桶名称，桶名称只支持英文小写。

创建一个bucket
![](images/addBucket.png)

输入bucket名称
![](images/addBucket2.png)

##### 2.1.2 文件上传
创建bucket 后，点击操作栏上的 上传文件 按钮，弹出的弹窗中会自动写入上传的桶名称、文件名称（上传文件名）、文件大小信息，点击 上传按钮即会自动将文件上传到对应的bucket 中。

上传文件到对应的bucket 中
![](images/addBucketFile.png)

填写上传表单（表单数据会自动填充，正常情况下无需修改）
![](images/addBucketFile2.png)

**注意：同一个bucket 下的文件名称必须唯一，否则后上传的会自动覆盖之前上传的文件！！！**

#### 2.2 文本数据接入
文本接入支持自定义 index。并将数据存储到指定的index中。

##### 2.2.1 文本存储设置
连接到Elasticsearch 管理平台
![](images/connectElasticsearch.png)

在右上角 Indices -> Indices Summary -> Create Index 中可以创建一个索引。
![](images/ElasticsearchIndex.png)

在Indices Summary页面中，点击右上角的Create Index 创建一个新的索引
![](images/ElasticsearchIndexCreate.png)

填写index 创建参数
![](images/ElasticsearchIndexCreateForm.png)

**创建参数说明：**

Name: 索引名称，即为Elasticsearch index 概念。

Number of Shards: Shards是将索引分成多个部分的逻辑单位。每个shard都是一个Lucene索引，由Elasticsearch集群中的多个节点共同维护。通常，增加shard的数量可以提高查询的并发性能，但同时也会增加系统的负载。推荐每个索引设置shards为5。

Number of Replicas:Replicas 是shard的副本。每个shard可以有多个replica，这些replica分别存储在Elasticsearch集群中的不同节点上，从而实现了数据的冗余备份和高可用性。增加replica的数量可以提高数据的可用性和容错能力，但同时也会占用更多的硬件资源。推荐每个索引设置Replicas为2.

##### 2.2.2 文本上传
可通过HTTP请求和java代码两种方式进行文本数据上传。

**HTTP请求上传数据**

可以通过HTTP请求上传文本数据到Elasticsearch，常用命令如下：
```shell
# 创建索引
# 命令格式：curl --user <username>:<password>  -X PUT 'http://<ip>:<port>/<indexName>'
# username: ES 用户名
# password: ES 用户密码
curl --user elastic:ZksUcu -X PUT 'http://172.16.104.112:19200/indexName'

# 添加索引映射关系数据
# _mapping接口：索引的映射关系在索引创建后可通过_mapping接口查看或修改
curl --user elastic:ZksUcu -X PUT "http://172.16.104.112:19200/indexName/_mapping" -H 'Content-Type: application/json' -d'
{
  "properties": {
     "_class": {
        "type": "text",
        "fields": {
           "keyword": {
              "type": "keyword",
              "ignore_above": 256
           }
        }
     },
     "goodsId": {
        "type": "text",
        "fields": {
           "keyword": {
              "type": "keyword",
              "ignore_above": 256
           }
        }
     },
     "goodsName": {
        "type": "text",
        "fielddata": true,
        "fields": {
           "keyword": {
              "type": "keyword",
              "ignore_above": 256
           }
        }
     },
     "thumbnail": {
        "type": "text",
        "fields": {
           "keyword": {
              "type": "keyword",
              "ignore_above": 256
           }
        }
     }
  }
}'

# 查询所有索引数据
curl --user elastic:ZksUcu -X GET 'http://172.16.104.112:19200/indexName/_doc'

# 写入文档数据
curl --user elastic:ZksUcu -X PUT "http://172.16.104.112:19200/indexName/_doc" -H 'Content-Type: application/json' -d'
{
	"goodsId": "A00001234",
	"goodsName": "测试商品",
	"thumbnail": "商品图片链接地址"
}'

# 查询所有文档数据
curl --user elastic:ZksUcu -X POST 'http://172.16.104.112:19200/indexname/_search'

# 按照检索条件查询索引数据
curl --user elastic:ZksUcu -X POST 'http://172.16.104.112:19200/indexName/_search' -H 'Content-Type: application/json' -d'
{
  "query": {
    "match_all": {}
  },
  "from": 0,
  "size": 10
}'

```

也可以在数字底座管理平台上查询index 中的数据
![](images/ElasticsearchIndexQuery.png)

**代码Java获取数据**

参见3.2 文本数据获取EsUtil 工具类。

### 3.数据使用
#### 3.1文件数据获取
文件数据下载可以使用以下MinioUtil 工具类获取.

```java
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import io.minio.*;
import io.minio.errors.*;
import io.minio.http.Method;
import io.minio.messages.Bucket;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.compress.utils.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import io.minio.messages.DeleteError;
import io.minio.messages.DeleteObject;
import io.minio.messages.Item;

/**
 * @Author: yangcheng
 * @Description:
 * @Date: create in 2023/5/6 16:24
 */
@Slf4j
@Component
public class MinioUtil {

    private static MinioClient  minioClient;

    @Autowired
    public void setConnection(MinioClient  minioClient) {
        MinioUtil.minioClient = minioClient;
    }

    /**
     * 判断bucket是否存在
     */
    public static boolean existBucket(String bucketName) {
        try {
            boolean exists = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());
            return exists;
        } catch (Exception e) {
            log.error("minio error",e);
        }

        return false;
    }

    /**
     * 创建存储bucket
     *
     * @param bucketName 存储bucket名称
     * @return Boolean
     */
    public static Boolean makeBucket(String bucketName) {
        try {
            minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build());
        } catch (Exception e) {
            log.error("minio error",e);
            return false;
        }

        return true;
    }

    /**
     * 删除存储bucket
     *
     * @param bucketName 存储bucket名称
     * @return Boolean
     */
    public static Boolean removeBucket(String bucketName) {
        try {
            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());
        } catch (Exception e) {
            log.error("minio error",e);

            return false;
        }

        return true;
    }

    /**
     * 查看bucket列表
     *
     * @return Boolean
     */
    public static List<Bucket> getBuckets() {
        try {
            List<Bucket> buckets = minioClient.listBuckets();
            return buckets;
        } catch (Exception e) {
            log.error("minio error",e);
            return null;
        }

    }

    /**
     * description: 上传文件（浏览器上传）
     *
     * @param multipartFile
     * @return : java.lang.String
     *
     */
    public static List<String> upload(MultipartFile[] multipartFile, String bucketName) {
        List<String> names = new ArrayList<>(multipartFile.length);

        for (MultipartFile file : multipartFile) {
            String fileName = file.getOriginalFilename();
            InputStream in = null;
            try {

                in = file.getInputStream();
                minioClient.putObject(PutObjectArgs.builder().bucket(bucketName).object(fileName)
                        .stream(in, in.available(), -1).contentType(file.getContentType()).build());
            } catch (Exception e) {
                log.error("minio error",e);
            } finally {

                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("minio error",e);
                    }
                }
            }
            names.add(fileName);
        }

        return names;
    }

    /**
     * description: 上传文件（浏览器上传）
     *
     * @param multipartFile
     * @return : java.lang.String
     *
     */
    public static Boolean uploadFile(MultipartFile multipartFile, String bucketName) {

            String fileName = multipartFile.getOriginalFilename();
            InputStream in = null;
            try {
                in = multipartFile.getInputStream();
                minioClient.putObject(PutObjectArgs.builder().bucket(bucketName).object(fileName)
                        .stream(in, in.available(), -1).contentType(multipartFile.getContentType()).build());
                return true;
            } catch (Exception e) {
                log.error("minio error",e);
                return false;
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
    }

    /**
     * 下载文件（适用于浏览器下载）
     *
     * @param fileName
     * @return : org.springframework.http.ResponseEntity<byte []>
     */
    public static ResponseEntity<byte[]> download(String fileName, String bucketName) {
        ResponseEntity<byte[]> responseEntity = null;
        InputStream in = null;
        ByteArrayOutputStream out = null;
        try {

            in = minioClient.getObject(GetObjectArgs.builder().bucket(bucketName).object(fileName).build());
            out = new ByteArrayOutputStream();
            IOUtils.copy(in, out);
            // 封装返回值
            byte[] bytes = out.toByteArray();
            HttpHeaders headers = new HttpHeaders();
            try {
                //告示浏览器文件的打开方式是下载
                headers.add("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileName, "utf-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
            headers.setContentLength(bytes.length);
            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
            headers.setAccessControlExposeHeaders(Arrays.asList("*"));
            responseEntity = new ResponseEntity<byte[]>(bytes, headers, HttpStatus.OK);
        } catch (Exception e) {
            log.error("minio error",e);
        } finally {
            try {

                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if (out != null) {
                    out.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return responseEntity;
    }

    /**
     * 查看文件对象
     *
     * @param bucketName 存储bucket名称
     * @return 存储bucket内文件对象信息
     */
    public static List<ObjectItem> listObjects(String bucketName) {
        Iterable<Result<Item>> results = minioClient.listObjects(ListObjectsArgs.builder().bucket(bucketName).build());
        List<ObjectItem> objectItems = new ArrayList<>();
        try {

            for (Result<Item> result : results) {
                Item item = result.get();
                ObjectItem objectItem = new ObjectItem();
                objectItem.setObjectName(item.objectName());
                objectItem.setSize(item.size());
                objectItems.add(objectItem);
            }
        } catch (Exception e) {
            log.error("minio error",e);
            return null;
        }

        return objectItems;
    }

    /**
     * 批量删除文件对象
     *
     * @param bucketName 存储bucket名称
     * @param objects    对象名称集合
     */
    public static Iterable<Result<DeleteError>> removeObjects(String bucketName, List<String> objects) {
        List<DeleteObject> dos = objects.stream().map(e -> new DeleteObject(e)).collect(Collectors.toList());
        Iterable<Result<DeleteError>> results = minioClient
                .removeObjects(RemoveObjectsArgs.builder().bucket(bucketName).objects(dos).build());

        return results;
    }

    /**
     * 获取文件流
     *
     * @param bucketName     桶
     * @param objectName 对象名称
     * @return InputStream 文件流
     * @throws Exception
     */
    public static InputStream getObjectInputStream(String bucketName, String objectName) throws Exception {
        InputStream inputStream = minioClient.getObject(GetObjectArgs.builder().bucket(bucketName).object(objectName).build());

        return inputStream;
    }

    /**
     * 获取文件流
     *
     * @param bucketName     桶
     * @param objectName 对象名称
     * @return byte[] 文件流
     * @throws Exception
     */
    public static byte[] getObjectByte(String bucketName, String objectName) throws Exception {
        InputStream inputStream = minioClient.getObject(GetObjectArgs.builder().bucket(bucketName).object(objectName).build());
        byte[] bytes = IOUtils.toByteArray(inputStream);
        return bytes;
    }
    /**
     * @return java.lang.String
     * @Description
     * @Date 12:14 2022/8/19
     * @Param [bucket=存储桶名称, fileName=文件路径即名称]
     **/
    public static String getMinioURL(String bucket, String fileName) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, ServerException, XmlParserException, InternalException, InsufficientDataException, ErrorResponseException {


        GetPresignedObjectUrlArgs build = GetPresignedObjectUrlArgs.builder()
                .method(Method.GET)
                .bucket(bucket)
                .object(fileName)
                .expiry(60 * 60 * 24)   //生成的预签名url可访问的有效时间，最大期限7天
                .build();
        return minioClient.getPresignedObjectUrl(build);
    }

    /**
     * @return java.lang.String
     * @Description
     * @Date 12:14 2022/8/19
     * @Param [bucket=存储桶名称, fileName=文件路径即名称]
     **/
    public static String uploadMinioURL(String bucket, String fileName) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, ServerException, XmlParserException, InternalException, InsufficientDataException, ErrorResponseException {


        String presignedUrl = minioClient.getPresignedObjectUrl(
                GetPresignedObjectUrlArgs.builder()
                        .method(Method.PUT)
                        .bucket(bucket)
                        .object(fileName)
                        .expiry(7 * 24 * 60 * 60) // Expires in 7 days (in seconds)
                        .build());
        return presignedUrl;
    }

}
```

```java
import lombok.Data;

/**
 * @Author: yangcheng
 * @Description:
 * @Date: create in 2023/5/6 16:36
 */
@Data
public class ObjectItem {

    private String objectName;

    private Long size;

}
```

```java
import io.minio.MinioClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: yangcheng
 * @Description:
 * @Date: create in 2023/5/6 16:20
 */

@Configuration
public class MinioClientConfig {

    @Value("${minio.url}")
    private String url;

    @Value("${minio.access-key}")
    private String accessKey;

    @Value("${minio.secret-key}")
    private String secretKey;

    /**
     * 注入minio客户端
     */
    @Bean
    public MinioClient minioClient() {

        return MinioClient.builder()
                .endpoint(url)
                .credentials(accessKey, secretKey)
                .build();
    }
}
```

#### 3.2 文本数据获取
文件数据下载可以使用以下EsUtil 工具类获取.
```java
package com.insigma.traffic.road.detection.common.utils;

/**
 * @ClassName EsUtil
 * @Description elasticsearch常用工具类
 * @Author hejianrong
 * @Date 2021/5/10 14:48
 * @Version 1.0
 **/

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
import org.elasticsearch.action.bulk.BulkRequest;
import org.elasticsearch.action.bulk.BulkResponse;
import org.elasticsearch.action.delete.DeleteRequest;
import org.elasticsearch.action.delete.DeleteResponse;
import org.elasticsearch.action.get.GetRequest;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.support.master.AcknowledgedResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.indices.CreateIndexRequest;
import org.elasticsearch.client.indices.CreateIndexResponse;
import org.elasticsearch.client.indices.GetIndexRequest;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.text.Text;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.index.reindex.BulkByScrollResponse;
import org.elasticsearch.index.reindex.DeleteByQueryRequest;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.fetch.subphase.FetchSourceContext;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;
import org.elasticsearch.search.sort.SortOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.StringUtils;

import java.io.IOException;
import java.util.*;

/**
 * es 的工具类
 *
 * @author czchen
 * @version 1.0
 * @date 2020/8/25 14:37
 */
@Slf4j
//@Component
public class EsUtil {

    @Autowired
    private RestHighLevelClient restHighLevelClient;


    /**
     * 关键字
     */
    public static final String KEYWORD = ".keyword";

    /**
     * 创建索引
     *
     * @param index 索引
     * @return
     */
    public boolean createIndex(String index) throws IOException {
        if (isIndexExist(index)) {
            log.error("Index is exits!");
            return false;
        }
        //1.创建索引请求
        CreateIndexRequest request = new CreateIndexRequest(index);
        //2.执行客户端请求
        CreateIndexResponse response = restHighLevelClient.indices().create(request, RequestOptions.DEFAULT);

        log.info("创建索引{}成功", index);

        return response.isAcknowledged();
    }

    /**
     * 删除索引
     *
     * @param index
     * @return
     */
    public boolean deleteIndex(String index) throws IOException {
        if (!isIndexExist(index)) {
            log.error("Index is not exits!");
            return false;
        }
        //删除索引请求
        DeleteIndexRequest request = new DeleteIndexRequest(index);
        //执行客户端请求
        AcknowledgedResponse delete = restHighLevelClient.indices().delete(request, RequestOptions.DEFAULT);

        log.info("删除索引{}成功", index);

        return delete.isAcknowledged();
    }


    /**
     * 判断索引是否存在
     *
     * @param index
     * @return
     */
    public boolean isIndexExist(String index) throws IOException {

        GetIndexRequest request = new GetIndexRequest(index);

        boolean exists = restHighLevelClient.indices().exists(request, RequestOptions.DEFAULT);

        return exists;
    }


    /**
     * 数据添加，正定ID
     *
     * @param jsonObject 要增加的数据
     * @param index      索引，类似数据库
     * @param id         数据ID, 为null时es随机生成
     * @return
     */
    public String addData(JSONObject jsonObject, String index, String id) throws IOException {

        //创建请求
        IndexRequest request = new IndexRequest(index);
        //规则 put /test_index/_doc/1
        request.id(id);
        request.timeout(TimeValue.timeValueSeconds(1));
        //将数据放入请求 json
        IndexRequest source = request.source(jsonObject, XContentType.JSON);
        //客户端发送请求
        IndexResponse response = restHighLevelClient.index(request, RequestOptions.DEFAULT);
        log.info("添加数据成功 索引为: {}, response 状态: {}, id为: {}", index, response.status().getStatus(), response.getId());
        return response.getId();
    }

    /**
     * 同步插入
     *
     * @param request
     * @param options
     * @return
     */
    public boolean batchAddData(BulkRequest request, RequestOptions options) {
//        IndexResponse response = restHighLevelClient.bulk(request, RequestOptions.DEFAULT);
        try {
            BulkResponse bulk = restHighLevelClient.bulk(request, options);
            if (bulk.status().getStatus() == 200) {
                log.info("batch insert success"
                );
                return true;
            }
        } catch (Exception e) {
            log.error("batch insert to es error,msg={}", e);
        }
        return false;
    }

    /**
     * 数据添加 随机id
     *
     * @param jsonObject 要增加的数据
     * @param index      索引，类似数据库
     * @return
     */
    public String addData(JSONObject jsonObject, String index) throws IOException {
        return addData(jsonObject, index, UUID.randomUUID().toString().replaceAll("-", "").toUpperCase());
    }

    /**
     * 通过ID删除数据
     *
     * @param index 索引，类似数据库
     * @param id    数据ID
     */
    public void deleteDataById(String index, String id) throws IOException {
        //删除请求
        DeleteRequest request = new DeleteRequest(index, id);
        //执行客户端请求
        DeleteResponse delete = restHighLevelClient.delete(request, RequestOptions.DEFAULT);
        log.info("索引为: {}, id为: {}删除数据成功", index, id);
    }


    /**
     * 根据自定义的查询方式进行数据删除
     *
     * @param queryBuilder 自定义查询
     * @param index        索引
     */
    public boolean deleteByQuery(QueryBuilder queryBuilder, String index) {
        try {
            DeleteByQueryRequest request = new DeleteByQueryRequest(index);
            request.setQuery(queryBuilder);
            BulkByScrollResponse resp = restHighLevelClient.deleteByQuery(request, RequestOptions.DEFAULT);
            log.info("delete success,deleted num= {}", resp.getStatus().getDeleted());
            return true;
        } catch (Exception e) {
            log.error("delete es data error,msg={}", e);
        }
        return false;

    }


    /**
     * 通过ID 更新数据
     *
     * @param object 要增加的数据
     * @param index  索引，类似数据库
     * @param id     数据ID
     * @return
     */
    public void updateDataById(Object object, String index, String id) throws IOException {
        //更新请求
        UpdateRequest update = new UpdateRequest(index, id);

        //保证数据实时更新
        //update.setRefreshPolicy("wait_for");

        update.timeout("1s");
        update.doc(JSON.toJSONString(object), XContentType.JSON);
        //执行更新请求
        UpdateResponse update1 = restHighLevelClient.update(update, RequestOptions.DEFAULT);
        log.info("索引为: {}, id为: {}, 更新数据成功", index, id);
    }


    /**
     * 通过ID 更新数据,保证实时性
     *
     * @param object 要增加的数据
     * @param index  索引，类似数据库
     * @param id     数据ID
     * @return
     */
    public void updateDataByIdNoRealTime(Object object, String index, String id) throws IOException {
        //更新请求
        UpdateRequest update = new UpdateRequest(index, id);

        //保证数据实时更新
        update.setRefreshPolicy("wait_for");

        update.timeout("1s");
        update.doc(JSON.toJSONString(object), XContentType.JSON);
        //执行更新请求
        UpdateResponse update1 = restHighLevelClient.update(update, RequestOptions.DEFAULT);
        log.info("索引为: {}, id为: {}, 更新数据成功", index, id);
    }


    /**
     * 通过ID获取数据
     *
     * @param index  索引，类似数据库
     * @param id     数据ID
     * @param fields 需要显示的字段，逗号分隔（缺省为全部字段）
     * @return
     */
    public Map<String, Object> searchDataById(String index, String id, String fields) throws IOException {
        GetRequest request = new GetRequest(index, id);
        if (!StringUtils.isEmpty(fields)) {
            //只查询特定字段。如果需要查询所有字段则不设置该项。
            request.fetchSourceContext(new FetchSourceContext(true, fields.split(","), Strings.EMPTY_ARRAY));
        }
        GetResponse response = restHighLevelClient.get(request, RequestOptions.DEFAULT);
        Map<String, Object> map = response.getSource();
        if (!Objects.isNull(map)) {
            //为返回的数据添加id
            map.put("id", response.getId());
        }
        return map;
    }

    /**
     * 通过ID判断文档是否存在
     *
     * @param index 索引，类似数据库
     * @param id    数据ID
     * @return
     */
    public boolean existsById(String index, String id) throws IOException {
        GetRequest request = new GetRequest(index, id);
        //不获取返回的_source的上下文
        request.fetchSourceContext(new FetchSourceContext(false));
        request.storedFields("_none_");
        return restHighLevelClient.exists(request, RequestOptions.DEFAULT);
    }

    /**
     * 获取低水平客户端
     *
     * @return
     */
    public RestClient getLowLevelClient() {
        return restHighLevelClient.getLowLevelClient();
    }


    /**
     * 高亮结果集 特殊处理
     * map转对象 JSONObject.parseObject(JSONObject.toJSONString(map), Content.class)
     *
     * @param searchResponse
     * @param highlightField
     */
    public List<Map<String, Object>> setSearchResponse(SearchResponse searchResponse, String highlightField) {
        //解析结果
        ArrayList<Map<String, Object>> list = new ArrayList<>();
        for (SearchHit hit : searchResponse.getHits().getHits()) {
            Map<String, HighlightField> high = hit.getHighlightFields();
            HighlightField title = high.get(highlightField);

            hit.getSourceAsMap().put("id", hit.getId());

            Map<String, Object> sourceAsMap = hit.getSourceAsMap();//原来的结果
            //解析高亮字段,将原来的字段换为高亮字段
            if (title != null) {
                Text[] texts = title.fragments();
                String nTitle = "";
                for (Text text : texts) {
                    nTitle += text;
                }
                //替换
                sourceAsMap.put(highlightField, nTitle);
            }
            list.add(sourceAsMap);
        }
        return list;
    }


    /**
     * 查询并分页
     *
     * @param index          索引名称
     * @param query          查询条件
     * @param size           文档大小限制
     * @param from           从第几页开始
     * @param fields         需要显示的字段，逗号分隔（缺省为全部字段）
     * @param sortField      排序字段
     * @param highlightField 高亮字段
     * @return
     */
    public List<Map<String, Object>> searchListData(String index,
                                                    SearchSourceBuilder query,
                                                    Integer size,
                                                    Integer from,
                                                    String fields,
                                                    String sortField,
                                                    String highlightField) throws IOException {
        SearchRequest request = new SearchRequest(index);
        SearchSourceBuilder builder = query;
        if (!StringUtils.isEmpty(fields)) {
            //只查询特定字段。如果需要查询所有字段则不设置该项。
            builder.fetchSource(new FetchSourceContext(true, fields.split(","), Strings.EMPTY_ARRAY));
        }
        from = from <= 0 ? 0 : from * size;
        //设置确定结果要从哪个索引开始搜索的from选项，默认为0
        builder.from(from);
        builder.size(size);
        if (!StringUtils.isEmpty(sortField)) {
            //排序字段，注意如果proposal_no是text类型会默认带有keyword性质，需要拼接.keyword
            builder.sort(sortField + ".keyword", SortOrder.ASC);
        }
        //高亮
        HighlightBuilder highlight = new HighlightBuilder();
        highlight.field(highlightField);
        //关闭多个高亮
        highlight.requireFieldMatch(false);
        highlight.preTags("<span style='color:red'>");
        highlight.postTags("</span>");
        builder.highlighter(highlight);
        //不返回源数据。只有条数之类的数据。
        //builder.fetchSource(false);
        request.source(builder);
        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);
        log.error("==" + response.getHits().getTotalHits());
        if (response.status().getStatus() == 200) {
            // 解析对象
            return setSearchResponse(response, highlightField);
        }
        return null;
    }

    /**
     * 自定义查询的request
     *
     * @param request        自定义请求
     * @param options        请求类型==RequestOptions.DEFAULT
     * @param highlightField 高亮字段，可为空
     * @return
     */
    public List<Map<String, Object>> searchListData(SearchRequest request, RequestOptions options, String highlightField) {
        try {
            SearchResponse response = restHighLevelClient.search(request, options);
            if (response.status().getStatus() == 200) {
                // 解析对象
                return setSearchResponse(response, highlightField);
            }

        } catch (Exception e) {
            log.error("自定义查询失败。msg={}", e);
        }
        return null;
    }
}
```

可在数字底座平台上查看和管理当前Elasticsearch 的索引和数据。

### 4.算法运行支撑
@博文 补充

### 5.资源运行监控
@建荣补充

### 6.主机管理
@建荣补充

### 7.应用权限
调用数字底座能力时，离不开调用服务端接口，这些操作会访问用户，操作用户的信息。在实际使用过程中，应用需要申请资源访问的权限，并经过开放平台
或者租户管理员审核后，才可以使用权限绑定的开放能力。开发者可以进入开发者后台，在权限管理页面的权限配置区域，批量开通所需的api权限和对应的插件能力。
权限列表

